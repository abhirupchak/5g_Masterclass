
- 5G supports **VoNR** (Voice over New Radio) and **ViNR** (Video over New Radio).

### RAN (Radio Access Network) Protocol Stack:

![userplane/controlprotocols](https://github.com/abhirupchak/images-5G_masterclass/blob/main/imagesch1/Screenshot%202024-10-15%20205053.png)

#### User Plane Protocol Stack:
All the protocols in this stack utilize the services of the protocol below them. The **UE (User Equipment) protocol** communicates with the **gNodeB protocols** to establish and maintain the connection.

- **PHY (Physical Layer)**: 
  - Responsible for efficient wireless communication.

- **MAC (Medium Access Control Layer)**: 
  - Functions include retransmission, multiplexing/demultiplexing, and scheduling.

- **RLC (Radio Link Control Layer)**: 
  - Implements **ARQ (Automatic Repeat Request)** for error correction.
  - Handles segmentation, breaking up data packets into smaller segments.

- **PDCP (Packet Data Convergence Protocol)**: 
  - Responsible for header control, ciphering, and integrity protection.
  - Performs duplicate removal.

- **SDAP (Service Data Adaptation Protocol)**: 
  - Matches the appropriate QoS bearer to the correct radio bearer.
  - For example, a voice call packet is treated differently from a streaming packet.

The input of each protocol layer is the output of the layer above it.

### Packet Flow Through 5G Protocol Layers

![sdu/pdu](https://github.com/abhirupchak/images-5G_masterclass/blob/main/imagesch2/Screenshot%202024-10-14%20120121.png)

### SDU and PDU:
- **SDU (Service Data Unit)**: Data received from the layer above.
- **PDU (Protocol Data Unit)**: Processed data with added headers, passed to the next layer.



![packetflow](https://github.com/abhirupchak/images-5G_masterclass/blob/main/imagesch2/Screenshot%202024-10-15%20211037.png)

1. **SDAP (Service Data Adaptation Protocol)**
   - Maps the **SDU** to the correct QoS bearer.
   - Outputs a **PDU** passed to the **PDCP** layer.

2. **PDCP (Packet Data Convergence Protocol)**
   - Handles header compression, encryption, and integrity protection.
   - Processes the **SDU** and generates a **PDU** for **RLC**.

3. **RLC (Radio Link Control Layer)**
   - Segments or concatenates the data.
   - Performs error correction using **ARQ**.
   - Produces a **PDU** for the **MAC** layer.

4. **MAC (Medium Access Control Layer)**
   - Handles multiplexing, scheduling, and retransmissions.
   - Organizes data into transport blocks (its **PDU**) and sends them to **PHY**.

5. **PHY (Physical Layer)**
   - Converts the **MAC PDU** into radio signals for transmission over the air.
## Control Plane Layer

![controlplanenas](https://github.com/user-attachments/assets/628d8811-4314-4fa5-ac06-9698fe0f5801)
![rrc](https://github.com/user-attachments/assets/0aa1bcbf-fe06-4b66-9f7f-fccb7873608f)

***SDAP***
Looking at the sdap layer in more detail,

![differenttraffic](https://github.com/user-attachments/assets/b10859f1-3b29-4c1c-866c-57c10891e515)

To manage all these types of traffic the sdap separates them into different QoS flows.

![qosflows](https://github.com/user-attachments/assets/3ba9a9d9-6a6c-4246-bae0-c01c4ad2b617)

There are different types of QoS flows

![gbr/ngbr](https://github.com/user-attachments/assets/8d072547-644a-4067-9a47-f76a71263325)

Guaranteed Bit Rate(GBR) -->for critical functions or voice calls.
and Non-Guaranteed Bit Rate(NGBR) --> for streaming or normal broadband connection where steady connection is not required.

![iptoQosflow](https://github.com/user-attachments/assets/23654246-b0ca-4c7f-a79a-177d33309594)

Multiplexing occurs at two points in the 5G ran system. The sdap converts IP packets to QoS flows at the core network as per requirement and The upf converts IP flow to QoS flows at the core network.
The SDAP maps each flow into radio bearers. The following example helps in understanding this.

![examplesdap](https://github.com/user-attachments/assets/c9e4bcf2-6857-4439-a03f-780cf93644e7)

***PDCP***

The PDCP does 4 tasks,
Firstly it compresses the headers which are 40 bytes in IPv4 and 60 in IPv6 which is almost as large as some smaller data packets, it follows the ROHC(Robust Header Compression).

![Headercompression](https://github.com/user-attachments/assets/a49cb0c2-16d6-41c4-9df3-5311375b818f)

 Ciphering and Integrity protection: Encrypts data and ensures data integrity for secure communication.

 **KRRC,ENC (Key for RRC Encryption)**: 
   - Used by pdcp to encrypt RRC (Radio Resource Control) messages, ensuring the confidentiality of control signaling between the UE and gNodeB.
 **KRRC,INT (Key for RRC Integrity Protection)**: 
   - Employed by pdcp to provide integrity protection for RRC messages, ensuring that control signaling is not altered or tampered with during transmission.
     
![encrytp&integrity](https://github.com/user-attachments/assets/821fc749-f43a-4ca8-ae1b-0caf99806923)


 Routing and Duplication: Sends data through two streams to achieve high reliabilty(one data gets lost other will still deliver) and higher data rates.

 ![duplication](https://github.com/user-attachments/assets/44a251b9-ae8d-4131-a4f6-7d9b2617651e)

Reordering: Ensures that out-of-order packets are correctly re-sequenced before delivery to higher layers. In-Sequence and Out-of-Sequence deliveries occur, for certain services like video streaming it is nescessary for packets to arrive at destination in order, so the pdcp waits untill all the pdus of previous layer have arrived and are in order before forwarding it to another layer.



![insquence](https://github.com/user-attachments/assets/aa93edbb-ed4e-4bfd-b39e-b443f2cdd003)

the left is for recieving right is for transmission.

![pdcp](https://github.com/user-attachments/assets/a1ae05a6-b130-459d-a336-5f3d208892c8)

***RLC(Radio Link Control)***

There are different modes of RLC for different data types.Some data types may not require some functions of RLC.

![rlcmode](https://github.com/user-attachments/assets/1d91c98e-2346-42f8-b5f4-04899262b2c3)

The header part in the rlc pdu contains some segmentation information, segmentation is the process of division of data packets for ease of transmission. The segmentation informations contains the order in which data packets have been divided which is utilised if they need to be arranged in order again.

![rlcsegment](https://github.com/user-attachments/assets/8e337dac-1fe1-49d4-8ef0-755f2aa7ef19)

Unlike 4G in 5G in sequence delivery is not compulsory and is handled by PDCP instead of RLC, this reduces buffer and delay.

Now we will be going through the process of transmission of data to see why <b>retransmission(ARQ)</b> is important.

![retransmission1](https://github.com/user-attachments/assets/179c2d64-f109-4159-8de3-e8e0895594c5)

When a packet does not arrive the reciever starts a timer until which all incoming packets are stopped.

![retrans2](https://github.com/user-attachments/assets/4a4b6c96-3066-4ae7-bed9-d2f9ad754f11)

In this case, the packet arrives before timer ends so transmission continues.

![retrans3](https://github.com/user-attachments/assets/8b254694-cca9-4aa0-b67a-547cf1388b98)

Now some more packets go missing.

![retrans4](https://github.com/user-attachments/assets/7a20e6a8-6159-4b8e-8da2-19100019a318)

Packets do not arrive before timer ends so reciever sends a control signal back to transmitter to <b>retransmit</b> missing packages.

![retrans5](https://github.com/user-attachments/assets/24cdece2-664a-4efe-be07-09bf9a4a8492)

Packets arrive successfully after transmitter recieves control signal.

![retrans6](https://github.com/user-attachments/assets/a2823b74-f3d9-4c17-a1c6-f35826693b46)

### MAC(Medium Access Control)

Some examples of **mac** channels are listed below

![macchannels](https://github.com/user-attachments/assets/3bef4a4e-7a4c-454b-96c2-0eca864ef9f5)

The MAC pdu consists of data recieved from earlier layers as well as MAC Control Elements(CE), the CE functions are listed below.

![maccontrolelement](https://github.com/user-attachments/assets/797a74e1-5260-4e47-b690-f33eae0be9cd)

The MAC layer is also responsible for distributing the data into different carriers through multiplexing.

![carrierdist](https://github.com/user-attachments/assets/5ce3cf13-843d-42fe-aacf-62ef4a05064f)

Hybrid ARQ(HARQ) is also carried out at this stage, in this process, transmission of several transport blocks happens simultaneously to reduce time consumption.
NR follows asynchronous ARQ process, i.e., the processes are processed dynamically via acknowledgement or non-acknowledgement feedback.

![harq](https://github.com/user-attachments/assets/fcdbc8d8-77d3-42f3-9c0c-37ee4962a352)

Since transport blocks can get quite large we divide it into CBGs (core block groups), so that if any error occurs only the CBG needs to be retransmitted instead of whole transport block.

![cbg](https://github.com/user-attachments/assets/87369edd-85a2-4656-a9fc-660519358ced)

***Scheduler**

The function of a scheduler is to allocate when and how much data is to be allocated to different users sharing the same data channel.

![scheduler](https://github.com/user-attachments/assets/7ecb85ca-0306-4347-a6d0-8cda2c750905)

The scheduler recieves input from RLC layer and physical layer and also from UE then produces output back to MAC layer.The gnodeb interacts with UE through CSI-RB and gets access of all nescessary information and also determines what time period should be used to communicate with the UE.

![scheduler+ue](https://github.com/user-attachments/assets/fda50c58-3447-4366-8869-4ec0799e24b6)

Now that all information has been gathered by gnodeb, it can start actually scheduling.GnodeB determines what channel each device will experience the best data rates in and distributes them accordingly, this is called channel dependent scheduling.

**Downlink Scheduling**

![channel/dependent](https://github.com/user-attachments/assets/7820b757-595a-4339-89eb-b40ec3bde1dc)

The scheduler also decides what amount of bandwidth is to be used by the device as per the service it is providing. This is known as reciever-bandwidth adaptation.

![reciever-bandadapt](https://github.com/user-attachments/assets/c7022a0e-fce8-47de-9d81-eb54b379ef2a)

If any data with more priority needs to bypass already transmitted data in the channel, a process called preemption occurs, here the green data(more priority) will overwrite the blue data and the device A(blue data) will be informed to ignore the green data. The lost blue data which has been overwritten will be error-corrected at reciever or retransmitted.

![preemption](https://github.com/user-attachments/assets/03b9a0d5-9a28-467c-9754-62172e2595ab)

For normal broadband usually dynamic scheduling occurs where the gnodeb informs the UE whenever data is transmitted, for URLLC there is a fixed interval after which data is automatically transmitted.

![scheduling/basedontime](https://github.com/user-attachments/assets/0683c3ea-fab1-4c6c-b91b-facb92385a40)

**Uplink Scheduling**

Now for uplink scheduling since UE(battery limited) is transmitting the SRS it has some drawbacks as compared to downlink which are listed below.

![uplink](https://github.com/user-attachments/assets/cc8aa148-6ab6-4409-b0f4-5faa872ce3b3)

**Physical Layer**

Physical is defined as given below, some components are also mentioned.

![phy](https://github.com/user-attachments/assets/289e3a2c-1e1e-496a-bb91-6bb85c78a0e0)

Physical layer can be considered as the most sophisticated it has many functions,

![phyfunctions](https://github.com/user-attachments/assets/282c93d4-ada7-4a39-ad8d-5ee7382b8428)

![crc](https://github.com/user-attachments/assets/1d6f3762-d795-4c8f-8d26-56ab83205e49)

![crc-->ldpc](https://github.com/user-attachments/assets/43d3e2be-1185-426d-b8b4-49f138f0a1d6)

![ldpc](https://github.com/user-attachments/assets/8f69c4ba-316f-4a38-a10a-e5de8bc38d65)

Each code block has ldpc coding applied to it. ldpc technique mentioned below.

![ldpc coding](https://github.com/user-attachments/assets/931e5faa-18fe-490c-b9bc-eac832dc62bc)

![ldpc](https://github.com/user-attachments/assets/3f288a2b-5ae9-4740-b448-7648aa4188f3)

<b>Rate matching</b> applied to each code block.

![rate matching](https://github.com/user-attachments/assets/65f8b6de-ac8d-4f85-b1e7-830501454d01)

Signals from other gnodeb are scrambled so that only intended signal reaches device. This is called <b>scrambling</b>

![scrambling](https://github.com/user-attachments/assets/9bcc5390-7726-4209-9188-4d6265c1763a)

**Modulation** is the process in which data is encoded onto a carrier signal.There are various types of supported modulation for different use cases.

![modulation](https://github.com/user-attachments/assets/d4788fb5-4f85-4d1b-b0c9-10daf8729d12)

Since NR supports MIMO which uses multiple layers, we have *layer mapping*. CW1 and CW2 are incoming signals.

![layermapping](https://github.com/user-attachments/assets/b9c31808-01c2-4f0c-9223-746b59418418)

So that the multiple inputs(layers) do not get mixed up we have precoding in place so that they can be individually be mapped to all the different virtual ports

![precoding](https://github.com/user-attachments/assets/da532206-5188-44a8-beaa-09640f1e523d)

The inputs recieved by the virtual antenna are then put into physical mapping with the help of MAC scheduler as well as control signals.

![virtual-->physicalmapping](https://github.com/user-attachments/assets/96eb1395-f7f6-47c2-bc70-a1ef322a23ab)

Now that we have physical signals we use beamforming technique.

![beamforming](https://github.com/user-attachments/assets/fb2b826b-39e8-4529-b062-1e33370df3e2)

![beamforming2](https://github.com/user-attachments/assets/e88ee6b1-904e-4ffa-a82b-fd93e94affd9)

Some techniques used by physical layer are as mentioned below:

![phylayersummary](https://github.com/user-attachments/assets/4a2205e8-4356-48d2-9a60-0b75525d1a50)

***RRC,NAS***

SDAP is unique as a user plane protocol, similarly RRC & NAS are unique to the control plane.

They have the following functions:

![rrc,nas.functions](https://github.com/user-attachments/assets/f64cd153-5a3e-4b0b-a9e1-114a9058034c)

There are various RRC states that the device goes through, inactive is a state introduced by NR so that device does not waste system resources when only small amount of data is to be sent to it. It can connect back very easily as well as compared to IDLE state.

![rrcstates](https://github.com/user-attachments/assets/0f318caf-d642-4fd0-9f19-c4d3e0ccf269)

The cells in the picture below are combined into RAN areas which are then combined into tracking areas, whenever device moves out of range some uodate needs to be sent to the core network, for tracking areas this is NAS registrations update and for RAN areas RRC update is sent. 

![rrcnas/idle&inactive](https://github.com/user-attachments/assets/1947bcb6-9813-4785-9ac6-6a17b690e296)

In idle and inactive mode ue controls mobility.

![uemobility](https://github.com/user-attachments/assets/c9155f1d-a767-4c00-9d80-689770cb07fc)

In connected mode, network controls mobility, device merely reports information of nearby cells to gnodeb

![connectedmobility](https://github.com/user-attachments/assets/1b378d91-8b0e-4437-9d99-e26ae6666a86)







